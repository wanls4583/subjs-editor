import CONST from '../../common/const.js';

export default [{
        reg: /^abstract\b/,
        value: 'abstract',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^arguments\b/,
        value: 'arguments',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^boolean\b/,
        value: 'boolean',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^break\b/,
        value: 'break',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^byte\b/,
        value: 'byte',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^case\b/,
        value: 'case',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^catch\b/,
        value: 'catch',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^char\b/,
        value: 'char',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^class\b/,
        value: 'class',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^const\b/,
        value: 'const',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^continue\b/,
        value: 'continue',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^debugger\b/,
        value: 'debugger',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^default\b/,
        value: 'default',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^delete\b/,
        value: 'delete',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^do\b/,
        value: 'do',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^double\b/,
        value: 'double',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^else\s*?if\b/,
        value: 'else if',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^else\b/,
        value: 'else',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^enum\b/,
        value: 'enum',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^eval\b/,
        value: 'eval',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^export\b/,
        value: 'export',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^extends\b/,
        value: 'extends',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^false\b/,
        value: 'false',
        type: CONST.CONSTANT_TYPE
    },
    {
        reg: /^final\b/,
        value: 'final',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^finally\b/,
        value: 'finally',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^float\b/,
        value: 'float',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^for\b/,
        value: 'for',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^function\b/,
        value: 'function',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^goto\b/,
        value: 'goto',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^if\b/,
        value: 'if',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^implements\b/,
        value: 'implements',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^import\b/,
        value: 'import',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^instanceof\b/,
        value: 'instanceof',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^int\b/,
        value: 'int',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^interface\b/,
        value: 'interface',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^let\b/,
        value: 'let',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^long\b/,
        value: 'long',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^native\b/,
        value: 'native',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^new\b/,
        value: 'new',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^null\b/,
        value: 'null',
        type: CONST.CONSTANT_TYPE
    },
    {
        reg: /^package\b/,
        value: 'package',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^private\b/,
        value: 'private',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^protected\b/,
        value: 'protected',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^public\b/,
        value: 'public',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^return\b/,
        value: 'return',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^short\b/,
        value: 'short',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^static\b/,
        value: 'static',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^super\b/,
        value: 'super',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^switch\b/,
        value: 'switch',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^synchronized\b/,
        value: 'synchronized',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^this\b/,
        value: 'this',
        type: CONST.IDENTIFIER_TYPE
    },
    {
        reg: /^throw\b/,
        value: 'throw',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^throws\b/,
        value: 'throws',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^transient\b/,
        value: 'transient',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^true\b/,
        value: 'true',
        type: CONST.CONSTANT_TYPE
    },
    {
        reg: /^try\b/,
        value: 'try',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^typeof\b/,
        value: 'typeof',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^var\b/,
        value: 'var',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^void\b/,
        value: 'void',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^volatile\b/,
        value: 'volatile',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^while\b/,
        value: 'while',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^with\b/,
        value: 'with',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^yield\b/,
        value: 'yield',
        type: CONST.KEYWORD_TYPE
    },
    {
        reg: /^\(/,
        value: '(',
        type: CONST.LEFT_PARENTHESES,
    },
    {
        reg: /^\)/,
        value: ')',
        type: CONST.RIGHT_PARENTHESES,
    },
    {
        reg: /^\[/,
        value: '[',
        type: CONST.LEFT_SQUARE_BRACKETS,
    },
    {
        reg: /^\]/,
        value: ']',
        type: CONST.RIGHT_SQUARE_BRACKETS,
    },
    {
        reg: /^\{/,
        value: '{',
        type: CONST.LEFT_BRACES,
    },
    {
        reg: /^\}/,
        value: '',
        type: CONST.RIGHT_BRACES,
    },
    {
        reg: /^'/,
        value: "'",
        type: CONST.SINGLE_QUOTATION_TYPE,
    },
    {
        reg: /^"/,
        value: '"',
        type: CONST.DOUBLE_QUOTATION_TYPE,
    },
    {
        reg: /^\/\*/,
        value: '/*',
        type: CONST.START_COMMENT_TYPE,
    },
    {
        reg: /^\*\//,
        value: '*/',
        type: CONST.END_COMMENT_TYPE,
    },
    {
        reg: /^\/\/[\s\S]*?$/,
        value: '',
        type: CONST.COMMENT_TYPE
    },
    {
        reg: /^\+\+/,
        value: '++',
        type: CONST.UNARY_OP_TYPE
    },
    {
        reg: /^\-\-/,
        value: '--',
        type: CONST.UNARY_OP_TYPE
    },
    {
        reg: /^\./,
        value: '.',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^===/,
        value: '===',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\!==/,
        value: '!==',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^==/,
        value: '==',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\!=/,
        value: '!=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\+=/,
        value: '+=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\-=/,
        value: '-=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\*=/,
        value: '*=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\/=/,
        value: '/=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\%=/,
        value: '%=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^<<=/,
        value: '<<=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^>>=/,
        value: '>>=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^>>>=/,
        value: '>>>=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\&=/,
        value: '&=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\^=/,
        value: '^=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\|=/,
        value: '|=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^<=/,
        value: '<=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^>=/,
        value: '>=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^=/,
        value: '=',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\!/,
        value: '!',
        type: CONST.UNARY_OP_TYPE
    },
    {
        reg: /^~/,
        value: '~',
        type: CONST.UNARY_OP_TYPE
    },
    {
        reg: /^\*/,
        value: '*',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\//,
        value: '/',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\+/,
        value: '+',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\-/,
        value: '-',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\%/,
        value: '%',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^<</,
        value: '<<',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^>>/,
        value: '>>',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^</,
        value: '<',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^>/,
        value: '>',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\&\&/,
        value: '&&',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\|\|/,
        value: '||',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\&/,
        value: '&',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\^/,
        value: '^',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\|/,
        value: '|',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\,/,
        value: ',',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^in\b/,
        value: 'in',
        type: CONST.BINARY_OP_TYPE
    },
    {
        reg: /^\?/,
        value: '?',
        type: CONST.TERNARY_OP_TYPE
    },
    {
        reg: /^\:/,
        value: ':',
        type: CONST.TERNARY_OP_TYPE
    },
    {
        reg: /^[\d]*?\.?[\d]+/,
        value: '',
        type: CONST.CONSTANT_TYPE
    },
    {
        reg: /^undefined/,
        value: 'undefined',
        type: CONST.CONSTANT_TYPE
    },
    {
        reg: /^[\$_a-zA-Z][\$_a-zA-Z0-9]*/,
        value: '',
        type: CONST.IDENTIFIER_TYPE
    },
    {
        reg: /^;/,
        value: ';',
        type: CONST.SEMICOLON_TYPE
    },
    {
        reg: /^\\/,
        value: '\\',
        type: CONST.ESCAPE_TYPE
    }
]